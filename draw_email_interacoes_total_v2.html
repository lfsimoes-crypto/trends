
<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Evolu√ß√£o intera√ß√µes email - total mercado</title>
  <style>
    :root{ --bg:#0b0b0f; --panel:#12121a; --text:#e8e8f0; --muted:#a8a8b8; --accent:#37d2ff; --accent2:#8f7bff; --good:#47d16a; --warn:#ffcc00; --bad:#ff5252; }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;}
    .wrap{max-width:820px; margin:28px auto; padding:0 16px;}
    .card{background:var(--panel); border:1px solid #1f1f2a; border-radius:16px; padding:18px 20px; box-shadow:0 10px 30px rgba(0,0,0,0.35);}
    h1{font-size:26px; margin:10px 0 6px; background: linear-gradient(90deg, var(--accent), var(--accent2)); -webkit-background-clip:text; background-clip:text; color:transparent;}
    p.lead{margin-top:0; color:var(--muted)}
    .chart-wrap{position:relative; width:576px; margin:0 auto;}
    #chart{background:#0f0f16; border-radius:12px; border:1px solid #1e1e29;}
    #drawOverlay{position:absolute; left:0; top:0; pointer-events:auto;}
    .controls{display:flex; gap:12px; flex-wrap:wrap; align-items:center; margin-top:14px; justify-content:center;}
    button{background:#1a1a26; color:var(--text); border:1px solid #2a2a3a; border-radius:10px; padding:10px 14px; cursor:pointer; font-weight:600;}
    button:hover{border-color:#3b3b4f}
    button.primary{background:linear-gradient(90deg,var(--accent),var(--accent2)); color:#0a0a0f; border:none;}
    .hint{color:var(--muted); font-size:14px; margin-top:10px; text-align:center}
    .acc-bar{margin:10px auto 14px; padding:10px 14px; width:576px; border-radius:12px; font-weight:800; letter-spacing:.2px; text-align:center; background:linear-gradient(90deg,#141427,#111128); border:1px solid #26264a; color:#e8e8f0;}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Evolution of the nb. of interactions using the Email channel - Total Market</h1>
      <p class="lead">Draw with your finger (or mouse) the expected evolution and compare it with the actual data. Period: 2015‚Äì2025.</p>
      <div id="accuracyBar" class="acc-bar">üéØ Accuracy: ‚Äî</div>
      <div class="chart-wrap">
        <canvas id="chart" width="576" height="312"></canvas>
        <canvas id="drawOverlay" width="576" height="312"></canvas>
      </div>
      <div class="controls">
        <button id="revealBtn" class="primary">Reveal real data</button>
        <button id="resetBtn">Clean chart</button>
        <button id="exportBtn">Export image</button>
      </div>
      <div class="hint">Tip: draw only in the shaded area (future). </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    const labels = ['2015','2016','2017','2018','2019','2020','2021','2022','2023','2024','2025*'];
    const realData = [502, 507, 517, 609, 695, 1884, 1694, 1559, 1586, 1799, 1971];
    const revealIndex = 4; // mostra 2015..2019; 2020..2025 ficam para o utilizador desenhar

    // History (blue)
    const history = realData.map((v,i)=> i<=revealIndex ? v : null);

    // Real Trend (green) ligado ao hist√≥rico
    const future = realData.map((v,i)=> i>revealIndex ? v : null);
    future[revealIndex] = history[revealIndex];

    // S√©rie do utilizador (amarelo) ‚Äî come√ßamos no √∫ltimo ponto hist√≥rico
    const userForecast = Array(labels.length).fill(null);
    userForecast[revealIndex] = history[revealIndex];

    const ctx = document.getElementById('chart').getContext('2d');
    const chart = new Chart(ctx, {
      type: 'line',
      data: {
        labels,
        datasets: [
          { label:'Histpry', data:history, borderColor:'#37d2ff', backgroundColor:'rgba(55,210,255,0.08)', borderWidth:3, tension:0.3, pointRadius:3 },
          { label:'Your forecast', data:userForecast, borderColor:'#ffcc00', backgroundColor:'rgba(255,204,0,0.08)', borderWidth:3, tension:0.25, pointRadius:0, spanGaps:true },
          { label:'Real data', data:future, borderColor:'#47d16a', backgroundColor:'rgba(71,209,106,0.08)', borderWidth:3, tension:0.25, pointRadius:3, hidden:true }
        ]
      },
      options: {
        responsive:false, maintainAspectRatio:false,
        plugins:{ legend:{ labels:{ color:'#e8e8f0'}}, tooltip:{enabled:true}},
        scales:{
          x:{ ticks:{color:'#c9c9da'}, grid:{color:'rgba(255,255,255,0.07)'}},
	  y:{ min: 0,// valor m√≠nimo fixo
  	      max: 2500, // valor m√°ximo fixo (ajusta conforme o teu caso)
	  ticks: { color:'#c9c9da' },
	  grid: { color:'rgba(255,255,255,0.07)' }

		}}
      }
    });

    // Overlay apenas para capturar eventos (sem desenhar linhas extras)
    const overlay = document.getElementById('drawOverlay');
    function rect(){ return overlay.getBoundingClientRect(); }
    let drawing=false, lastDrawIdx=revealIndex, lastDrawVal=history[revealIndex];

    function toChartValue(clientX, clientY){
      const r = rect(); const xPix = clientX - r.left; const yPix = clientY - r.top;
      const xScale = chart.scales.x; const yScale = chart.scales.y;
      const xValue = xScale.getValueForPixel(xPix); const yValue = yScale.getValueForPixel(yPix);
      return { xPix, yPix, xValue, yValue };
    }
    function nearestIndex(xValue){
      let idx = Math.round(xValue);
      if (idx <= revealIndex) idx = revealIndex + 1;
      if (idx >= labels.length) idx = labels.length - 1;
      return idx;
    }

    function startDraw(e){
      drawing = true;
      const t = (e.touches && e.touches[0]) ? e.touches[0] : e;
      const pos = toChartValue(t.clientX, t.clientY);
      lastDrawIdx = nearestIndex(pos.xValue);
      lastDrawVal = pos.yValue;
      userForecast[lastDrawIdx] = lastDrawVal;
      chart.update('none');
    }
    function draw(e){
      if (!drawing) return;
      const t = (e.touches && e.touches[0]) ? e.touches[0] : e;
      const pos = toChartValue(t.clientX, t.clientY);
      const idx = nearestIndex(pos.xValue);
      const val = pos.yValue;

      // Interpolar entre o √∫ltimo √≠ndice e o atual para linha cont√≠nua
      if (idx !== lastDrawIdx) {
        const start = Math.min(lastDrawIdx, idx);
        const end   = Math.max(lastDrawIdx, idx);
        const v0 = lastDrawVal;
        const v1 = val;
        for (let k = start; k <= end; k++) {
          const t = (end === start) ? 1 : (k - start) / (end - start);
          userForecast[k] = v0 + t * (v1 - v0);
        }
      } else {
        userForecast[idx] = val;
      }
      lastDrawIdx = idx;
      lastDrawVal = val;
      chart.update('none');
    }
    function endDraw(){ drawing=false; }

    overlay.addEventListener('mousedown', startDraw);
    overlay.addEventListener('mousemove', draw);
    overlay.addEventListener('mouseup', endDraw);
    overlay.addEventListener('mouseleave', endDraw);
    overlay.addEventListener('touchstart', startDraw, {passive:true});
    overlay.addEventListener('touchmove', draw, {passive:true});
    overlay.addEventListener('touchend', endDraw);

    function setAccuracyUI(accuracy){
      const bar = document.getElementById('accuracyBar');
      let color = '#ff5252';
      if (accuracy >= 90) color = '#47d16a';
      else if (accuracy >= 70) color = '#ffcc00';
      bar.style.borderColor = color;
      bar.style.color = color;
      bar.textContent = 'üéØ Precis√£o: ' + accuracy.toFixed(1) + '%';
    }

    document.getElementById('revealBtn').addEventListener('click', ()=>{
      chart.data.datasets[2].hidden = false;
      chart.update();

      let sumError = 0, count = 0;
      for (let i=revealIndex+1; i<labels.length; i++) {
        if (userForecast[i] != null && realData[i] != null && realData[i] !== 0) {
          const error = Math.abs(realData[i] - userForecast[i]) / Math.abs(realData[i]);
          sumError += error; count++;
        }
      }
      const accuracy = count > 0 ? (100 - (sumError / count) * 100) : 0;
      setAccuracyUI(accuracy);
    });

    document.getElementById('resetBtn').addEventListener('click', ()=>{
      for (let i=revealIndex+1; i<labels.length; i++) userForecast[i] = null;
      userForecast[revealIndex] = history[revealIndex];
      chart.data.datasets[2].hidden = true; chart.update();
      const bar = document.getElementById('accuracyBar');
      bar.textContent = 'üéØ Precis√£o: ‚Äî';
      bar.style.color = '#e8e8f0';
      bar.style.borderColor = '#26264a';
    });

    document.getElementById('exportBtn').addEventListener('click', ()=>{
      const merged = document.createElement('canvas'); merged.width = overlay.width; merged.height = overlay.height;
      const mctx = merged.getContext('2d'); mctx.drawImage(document.getElementById('chart'), 0, 0); // overlay vazio (sem tra√ßos)
      const link = document.createElement('a'); link.download = 'draw_email_interacoes_total_v2.png'; link.href = merged.toDataURL('image/png'); link.click();
    });

    function shadeFuture(){
      const xScale = chart.scales.x;
      const startPix = xScale.getPixelForValue(revealIndex + 0.5);
      const ctxChart = chart.ctx;
      const chartArea = chart.chartArea;
      ctxChart.save();
      ctxChart.fillStyle = 'rgba(255,255,255,0.06)';
      ctxChart.fillRect(startPix, chartArea.top, chartArea.right - startPix, chartArea.bottom - chartArea.top);
      ctxChart.restore();
    }
    const _draw = chart.draw.bind(chart);
    chart.draw = function(){ _draw(); shadeFuture(); };
    chart.update();
  </script>
</body>
</html>
