<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Total interactions (Millions) â€“ Total Market</title>
  <style>
    :root{ --bg:#0b0b0f; --panel:#12121a; --text:#e8e8f0; --muted:#a8a8b8; --accent:#37d2ff; --accent2:#8f7bff; --good:#47d16a; --warn:#ffcc00; --bad:#ff5252; }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;}
    .wrap{max-width:860px; margin:20px auto; padding:0 14px;}
    .card{background:var(--panel); border:1px solid #1f1f2a; border-radius:16px; padding:16px 18px; box-shadow:0 10px 30px rgba(0,0,0,0.35);}
    h1{font-size:clamp(20px, 2.8vw, 26px); margin:10px 0 6px; background: linear-gradient(90deg, var(--accent), var(--accent2)); -webkit-background-clip:text; background-clip:text; color:transparent;}
    p.lead{margin-top:0; color:var(--muted); font-size:clamp(13px, 1.8vw, 15px)}

    .chart-wrap{position:relative; width:100%; max-width:640px; margin:0 auto;}
    canvas{display:block; width:100% !important; height:auto !important;}
    #drawOverlay{position:absolute; inset:0; pointer-events:auto;}

    .controls{display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:12px; justify-content:center;}
    button{background:#1a1a26; color:var(--text); border:1px solid #2a2a3a; border-radius:10px; padding:10px 14px; cursor:pointer; font-weight:600; font-size:14px;}
    button:hover{border-color:#3b3b4f}
    button.primary{background:linear-gradient(90deg,var(--accent),var(--accent2)); color:#0a0a0f; border:none;}
    .hint{color:var(--muted); font-size:12px; margin-top:8px; text-align:center}
    .acc-bar{margin:8px auto 12px; padding:10px 14px; width:min(100%,640px); border-radius:12px; font-weight:800; letter-spacing:.2px; text-align:center; background:linear-gradient(90deg,#141427,#111128); border:1px solid #26264a; color:#e8e8f0; font-size:14px;}

    /* Fullscreen fallback */
    body.fs-active{overflow:hidden;}
    .chart-wrap.fs-fallback{
      position:fixed; inset:10px; z-index:9999; max-width:none; width:calc(100vw - 20px); height:auto;
      background:#0f0f16; border-radius:12px; border:1px solid #1e1e29;
    }
    .close-fs{
      position:fixed; z-index:10000; right:16px; top:12px; padding:8px 12px; border-radius:10px;
      background:#1a1a26; color:#e8e8f0; border:1px solid #2a2a3a; font-weight:700; display:none;
    }
    .close-fs.show{display:block;}

    /* â€”â€” MOBILE: taller chart for drawing â€”â€” */
    @media (max-width: 640px){
      .chart-wrap{
        height: 30vh;         /* ajusta para 70â€“75vh se quiseres ainda mais alto */
        max-height: 720px;
      }
      #chart, #drawOverlay{
        height: 100% !important;
      }
    }
  </style>
</head>
<body>
  <button id="closeFsBtn" class="close-fs">Exit Fullscreen âœ•</button>

  <div class="wrap">
    <div class="card">
      <h1>Evolution of the total nb. of interactions â€“ All Channels</h1>
      <p class="lead">Draw with your finger (or mouse) the expected evolution and compare it with the actual data. Period: 2015â€“2025.</p>
      <div id="accuracyBar" class="acc-bar">ðŸŽ¯ Accuracy: â€”</div>

      <div class="chart-wrap" id="chartWrap">
        <canvas id="chart"></canvas>
        <canvas id="drawOverlay"></canvas>
      </div>

      <div class="controls">
        <button id="revealBtn" class="primary">Reveal real data</button>
        <button id="resetBtn">Clean chart</button>
        <button id="exportBtn">Export image</button>
        <button id="fullBtn" aria-pressed="false">Fullscreen</button>
      </div>

      <div class="hint">Tip: draw only in the shaded area (future).</div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    const labels   = ['2015','2016','2017','2018','2019','2020','2021','2022','2023','2024','2025*'];
    const realData = [3.9, 3.7, 4.4, 4.4, 4.7, 5.4, 5.3, 5.4, 5.5, 5.6, 5.4];
    const revealIndex = 4;

    const history = realData.map((v,i)=> i<=revealIndex ? v : null);
    const future  = realData.map((v,i)=> i>revealIndex ? v : null);
    future[revealIndex] = history[revealIndex];

    const userForecast = Array(labels.length).fill(null);
    userForecast[revealIndex] = history[revealIndex];

    const isMobile = window.matchMedia('(max-width:640px)').matches;

    const chart = new Chart(document.getElementById('chart').getContext('2d'), {
      type: 'line',
      data: { labels,
        datasets: [
          { label:'History',        data:history,     borderColor:'#37d2ff', backgroundColor:'rgba(55,210,255,0.08)', borderWidth:3,              tension:0.3,  pointRadius:3 },
          { label:'Your forecast',  data:userForecast,borderColor:'#ffcc00', backgroundColor:'rgba(255,204,0,0.08)',  borderWidth:(isMobile?4:3), tension:0.25, pointRadius:0, spanGaps:true },
          { label:'Real data',      data:future,      borderColor:'#47d16a', backgroundColor:'rgba(71,209,106,0.08)', borderWidth:3,              tension:0.25, pointRadius:3, hidden:true }
        ]
      },
      options: {
        responsive:true,
        maintainAspectRatio:false, /* respeita a altura do CSS (mobile 65vh) */
        layout:{ padding:{ top:6, right:8, bottom:6, left:6 }},
        plugins:{ legend:{ labels:{ color:'#e8e8f0'}}, tooltip:{enabled:true}},
        scales:{
          x:{ ticks:{color:'#c9c9da'}, grid:{color:'rgba(255,255,255,0.07)'}},
          y:{ min:0, max:10, ticks:{color:'#c9c9da'}, grid:{color:'rgba(255,255,255,0.07)'} }
        }
      }
    });

    const overlay    = document.getElementById('drawOverlay');
    const chartWrap  = document.getElementById('chartWrap');
    const closeFsBtn = document.getElementById('closeFsBtn');
    const fullBtn    = document.getElementById('fullBtn');

    /* ---------- Overlay sync ---------- */
    function syncOverlay(){
      const c = chart.canvas;
      overlay.style.width  = c.style.width;
      overlay.style.height = c.style.height;
      overlay.width  = c.width;
      overlay.height = c.height;
      overlay.style.left = c.offsetLeft + 'px';
      overlay.style.top  = c.offsetTop + 'px';
    }
    const ro = new ResizeObserver(()=>{ chart.resize(); syncOverlay(); });
    ro.observe(chart.canvas);
    window.addEventListener('orientationchange', ()=> setTimeout(()=>{ chart.resize(); syncOverlay(); }, 120));
    window.addEventListener('resize',            ()=> setTimeout(()=>{ chart.resize(); syncOverlay(); }, 120));
    syncOverlay();

    /* ---------- Drawing ---------- */
    function rect(){ return overlay.getBoundingClientRect(); }
    let drawing=false, lastDrawIdx=revealIndex, lastDrawVal=history[revealIndex];

    function toChartValue(clientX, clientY){
      const r = rect(); const xPix = clientX - r.left; const yPix = clientY - r.top;
      const xScale = chart.scales.x; const yScale = chart.scales.y;
      return { xValue: xScale.getValueForPixel(xPix), yValue: yScale.getValueForPixel(yPix) };
    }
    function nearestIndex(xValue){
      let idx = Math.round(xValue);
      if (idx <= revealIndex) idx = revealIndex + 1;
      if (idx >= labels.length) idx = labels.length - 1;
      return idx;
    }

    function startDraw(e){
      drawing = true;
      const t = (e.touches && e.touches[0]) ? e.touches[0] : e;
      const pos = toChartValue(t.clientX, t.clientY);
      lastDrawIdx = nearestIndex(pos.xValue);
      lastDrawVal = pos.yValue;
      userForecast[lastDrawIdx] = lastDrawVal;
      chart.update('none');
    }
    function draw(e){
      if (!drawing) return;
      const t = (e.touches && e.touches[0]) ? e.touches[0] : e;
      const pos = toChartValue(t.clientX, t.clientY);
      const idx = nearestIndex(pos.xValue);
      const val = pos.yValue;

      if (idx !== lastDrawIdx){
        const start = Math.min(lastDrawIdx, idx);
        const end   = Math.max(lastDrawIdx, idx);
        const v0 = lastDrawVal, v1 = val;
        for (let k = start; k <= end; k++){
          const tt = (end === start) ? 1 : (k - start) / (end - start);
          userForecast[k] = v0 + tt * (v1 - v0);
        }
      } else {
        userForecast[idx] = val;
      }
      lastDrawIdx = idx; lastDrawVal = val;
      chart.update('none');
    }
    function endDraw(){ drawing=false; }

    overlay.addEventListener('mousedown', startDraw);
    overlay.addEventListener('mousemove', draw);
    overlay.addEventListener('mouseup', endDraw);
    overlay.addEventListener('mouseleave', endDraw);
    overlay.addEventListener('touchstart', startDraw, {passive:true});
    overlay.addEventListener('touchmove', draw, {passive:true});
    overlay.addEventListener('touchend', endDraw);

    /* ---------- Accuracy ---------- */
    function setAccuracyUI(accuracy){
      const bar = document.getElementById('accuracyBar');
      let color = '#ff5252';
      if (accuracy >= 90) color = '#47d16a';
      else if (accuracy >= 70) color = '#ffcc00';
      bar.style.borderColor = color;
      bar.style.color = color;
      bar.textContent = 'ðŸŽ¯ Accuracy: ' + accuracy.toFixed(1) + '%';
    }

    document.getElementById('revealBtn').addEventListener('click', ()=>{
      chart.data.datasets[2].hidden = false;
      chart.update();
      let sumError = 0, count = 0;
      for (let i=revealIndex+1; i<labels.length; i++){
        if (userForecast[i] != null && realData[i] != null && realData[i] !== 0){
          const error = Math.abs(realData[i] - userForecast[i]) / Math.abs(realData[i]);
          sumError += error; count++;
        }
      }
      const accuracy = count > 0 ? (100 - (sumError / count) * 100) : 0;
      setAccuracyUI(accuracy);
    });

    document.getElementById('resetBtn').addEventListener('click', ()=>{
      for (let i=revealIndex+1; i<labels.length; i++) userForecast[i] = null;
      userForecast[revealIndex] = history[revealIndex];
      chart.data.datasets[2].hidden = true; chart.update();
      const bar = document.getElementById('accuracyBar');
      bar.textContent = 'ðŸŽ¯ Accuracy: â€”';
      bar.style.color = '#e8e8f0';
      bar.style.borderColor = '#26264a';
    });

    document.getElementById('exportBtn').addEventListener('click', ()=>{
      const link = document.createElement('a');
      link.download = 'draw_email_interactions_fullscreen_mobile.png';
      link.href = chart.canvas.toDataURL('image/png');
      link.click();
    });

    /* ---------- Shade future area ---------- */
    function shadeFuture(){
      const xScale = chart.scales.x;
      const startPix = xScale.getPixelForValue(revealIndex + 0.5);
      const ctx = chart.ctx, area = chart.chartArea;
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      ctx.fillRect(startPix, area.top, area.right - startPix, area.bottom - area.top);
      ctx.restore();
    }
    const _draw = chart.draw.bind(chart);
    chart.draw = function(){ _draw(); shadeFuture(); };

    /* ---------- Fullscreen with toggle text ---------- */
    let fsFallbackActive = false;

    function updateFsUI(active){
      fullBtn.textContent = active ? 'Exit Fullscreen' : 'Fullscreen';
      fullBtn.setAttribute('aria-pressed', String(active));
      closeFsBtn.classList.toggle('show', active && (fsFallbackActive || !!document.fullscreenElement));
      setTimeout(()=>{ chart.resize(); syncOverlay(); }, 50);
    }

    async function enterFullscreen(){
      try{
        if (chartWrap.requestFullscreen){
          await chartWrap.requestFullscreen();
          fsFallbackActive = false;
        } else {
          // Fallback iOS
          document.body.classList.add('fs-active');
          chartWrap.classList.add('fs-fallback');
          fsFallbackActive = true;
        }
        updateFsUI(true);
      }catch(e){ console.warn('Fullscreen not available', e); }
    }

    function exitFullscreen(){
      if (document.fullscreenElement){ document.exitFullscreen(); }
      document.body.classList.remove('fs-active');
      chartWrap.classList.remove('fs-fallback');
      fsFallbackActive = false;
      updateFsUI(false);
    }

    // BotÃ£o principal alterna
    fullBtn.addEventListener('click', ()=>{
      const active = fsFallbackActive || !!document.fullscreenElement;
      if (active) exitFullscreen(); else enterFullscreen();
    });

    // BotÃ£o flutuante (fallback ou API)
    closeFsBtn.addEventListener('click', exitFullscreen);

    // Sincroniza estado quando o utilizador usa ESC ou controlos do SO
    document.addEventListener('fullscreenchange', ()=>{
      const active = !!document.fullscreenElement;
      if (!active && !fsFallbackActive) updateFsUI(false);
      else updateFsUI(true);
    });

    // ESC para o fallback
    document.addEventListener('keydown', (e)=>{
      if (e.key === 'Escape' && fsFallbackActive){ exitFullscreen(); }
    });
  </script>
</body>
</html>
